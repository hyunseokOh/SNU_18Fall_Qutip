from qutip import *
from qutip.ui.progressbar import TextProgressBar as ProgressBar
import numpy as np
import matplotlib.pyplot as plt

options=Options(nsteps=20000)

def calculate():
    #  rmat=np.zeros((len(tlist)),6)
    c_ops=[]

    if g1>0.0:
        c_ops.append(np.sqrt(g1)*sigmam())

    if g2>0.0:
        c_ops.append(np.sqrt(g2)*sigmaz())

    e_ops=[sigmax(),sigmay(),sigmaz()]
    
    wmw=frelist[0]
    args={'wmw':wmw}
    #  H0=(w01/2.0)*tensor(sigmaz(),qeye(2))+(w02/2.0)*tensor(qeye(2),sigmaz())+(J12/2.0)*tensor(sigmaz(),sigmaz())
    #  H1=Bac*tensor(sigmax(),qeye(2))
    #  H=[H0,[H1,'np.cos(wmw*t)']]
    H0=(w01-wmw)/2*tensor(sigmaz(),qeye(2))+(w02-wmw)/2*tensor(qeye(2),sigmaz())+J12/2*tensor(sigmaz(),sigmaz())
    Hint=(Bac1/4)*tensor(sigmax(),qeye(2))+(Bac2/4)*tensor(qeye(2),sigmax())
    H=H0+Hint
    output=mesolve(H,rho0,tlist,c_ops,[tensor(sigmax(),qeye(2)),tensor(sigmay(),qeye(2)),tensor(sigmaz(),qeye(2)),tensor(qeye(2),sigmax()),tensor(qeye(2),sigmay()),tensor(qeye(2),sigmaz())],args,options=options)

    return output.expect
       
w01=10*2*np.pi
w02=20*2*np.pi
Bac1=0*2*np.pi
Bac2=1*2*np.pi
J12=10*2*np.pi
g1=0.0
g2=0.0

psi1=basis(2,1) 
psi2=1/np.sqrt(2)*(basis(2,0)+basis(2,1))


rho0=ket2dm(tensor(psi1,psi2))
tlist=np.linspace(0,2*np.pi/Bac2,2)

frelist=[10*2*np.pi]
rmat=calculate()

b1=Bloch()
b2=Bloch()

vec1=[]
vec2=[]

for i in range(len(tlist)):
    vec1=[rmat[0][i],rmat[1][i],rmat[2][i]]
    vec2=[rmat[3][i],rmat[4][i],rmat[5][i]]
    b1.add_vectors(vec1)
    b2.add_vectors(vec2)
print(vec1)
b1.show()
b2.show()

fidelity(rho0,ket2dm(tensor(vec1,vec2)))
